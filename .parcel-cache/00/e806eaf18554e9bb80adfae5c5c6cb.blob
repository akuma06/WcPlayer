export var PlayerType;
(function (PlayerType) {
    PlayerType[PlayerType["AUDIO"] = 0] = "AUDIO";
    PlayerType[PlayerType["VIDEO"] = 1] = "VIDEO";
})(PlayerType || (PlayerType = {}));
export class AbstractPlayer extends HTMLElement {
    constructor(parent) {
        super();
        this.volume = 1;
        this.muted = false;
        this.duration = 0;
        this.currentTime = 0;
        this.textTracks = [];
        this.parent = parent;
    }
    static matchElement(el) {
        return this.match(el.getAttribute('src'));
    }
    static match(source) {
        return false;
    }
    static get observedAttributes() {
        return ['source', 'type', 'quality'];
    }
    get autoplay() {
        return this.hasAttribute('autoplay');
    }
    get source() {
        return this.hasAttribute('source') ? this.getAttribute('source') : '';
    }
    set source(src) {
        if (src !== this.source)
            this.setAttribute('source', src);
    }
    get quality() {
        return this.hasAttribute('quality') ? parseInt(this.getAttribute('quality')) : 0;
    }
    set quality(quality) {
        if (quality !== this.quality)
            this.setAttribute('quality', quality.toString());
    }
    addEventListener(type, listener, options) {
        super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
    }
    emit(type, ev) {
        super.dispatchEvent(new CustomEvent(type, { detail: ev }));
    }
}
export class PlayerConstructor extends AbstractPlayer {
    play() {
        throw new Error('Method not implemented.');
    }
    pause() {
        throw new Error('Method not implemented.');
    }
    seek(t) {
        throw new Error('Method not implemented.');
    }
    stop() {
        throw new Error('Method not implemented.');
    }
    getAvailableQualities() {
        throw new Error('Method not implemented.');
    }
}
//# sourceMappingURL=PlayerInterface.js.map